<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Trout Area Simulator - Enhanced v2.1</title>
    <!--
    V2.1 UPDATE: PAUSE-AND-DROP RETRIEVES
    - Configurable pause-and-drop technique (count, duration, location)
    - Free-fall physics during pauses (realistic sink modeling)
    - Trigger effect: 100% flutter quality spike after pause resume
    - Optimizer tests pause configurations (4x more combinations)
    - Visual pause markers on trajectory graph
    - Save/load pause settings in pattern library

    V2.0 MAJOR UPGRADE:
    - Advanced physics: realistic buoyancy, stall behavior, flutter modeling
    - Enhanced optimizer: 10x+ more combinations tested
    - Advanced scoring: flutter quality, fish trigger probability, depth stability
    - Expanded retrieves: acceleration, pulsing, multi-depth options
    - Pattern library: save/load favorite retrieves
    - Performance: result caching for faster updates
    -->
    
    <link rel="stylesheet" href="https://pyscript.net/releases/2023.05.1/pyscript.css" />
    <script defer src="https://pyscript.net/releases/2023.05.1/pyscript.js"></script>

    <style>
        :root { --sidebar-width: 350px; --primary: #28a745; --bg: #f0f2f5; }
        body { margin: 0; padding: 0; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; background: var(--bg); overflow-x: hidden; }
        
        .app-container { display: flex; flex-direction: column; min-height: 100vh; }
        
        /* PLOT AREA */
        .main-area { order: 1; width: 100%; background: white; padding-bottom: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.05); z-index: 2; }
        
        #plot-area { 
            width: 100%;
            display: flex; 
            justify-content: center; 
            margin: 0; 
            padding: 0; 
        }
        
        #cheat-sheet-container { padding: 10px 15px; }
        
        #cheat-sheet { 
            background: #e8f5e9; 
            border-left: 5px solid var(--primary); 
            padding: 12px; 
            border-radius: 4px; 
            font-family: monospace; 
            font-size: 0.9rem; 
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        #color-strategy {
            background: #fff3cd;
            border-left: 5px solid #ffc107;
            padding: 10px;
            margin-top: 10px;
            border-radius: 4px;
            font-size: 0.85rem;
        }
        #color-preview-container {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }
        .color-swatch {
            border: 1px solid #ccc;
            border-radius: 6px;
            text-align: center;
            font-size: 0.8rem;
            padding-bottom: 5px;
            overflow: hidden;
        }
        .swatch-pair { display: flex; height: 40px; }
        .swatch { width: 50%; }

        /* CONTROLS */
        .sidebar { order: 2; padding: 15px; background: var(--bg); padding-bottom: 80px; }

        @media (min-width: 900px) {
            .app-container { flex-direction: row; height: 100vh; overflow: hidden; }
            .sidebar { order: 1; width: var(--sidebar-width); height: 100%; overflow-y: auto; border-right: 1px solid #ddd; padding-bottom: 20px; background: white; }
            .main-area { order: 2; flex: 1; height: 100%; overflow-y: auto; padding: 20px; background: var(--bg); }
            #plot-area { width: 100%; max-width: 900px; border-radius: 12px; overflow: hidden; min-width: auto; }
        }

        /* TABS */
        .tabs { display: flex; background: #e0e0e0; border-radius: 8px; padding: 4px; margin-bottom: 15px; }
        .tab-button { flex: 1; padding: 10px; text-align: center; background: transparent; border: none; font-weight: 600; cursor: pointer; border-radius: 6px; font-size: 0.9rem; color: #555; }
        .tab-button.active { background: white; color: var(--primary); box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
        .tab-content { display: none; }
        .tab-content.active { display: block; }

        /* STICKY HEADER */
        .mobile-sticky-header {
            display: none; /* Hidden on desktop */
            position: sticky;
            top: 0;
            background: var(--bg);
            padding: 10px 10px;
            z-index: 10;
            border-bottom: 1px solid #ddd;
        }

        @media (max-width: 899px) {
            .mobile-sticky-header { display: block; }
            .main-area { padding-top: 0; }
            #cheat-sheet-container { display: none; }
        }

        /* WIDGETS */
        .widget-card { margin-bottom: 10px; border: 1px solid #ddd; border-radius: 8px; background: white; overflow: hidden; padding: 15px; }
        .control-group { margin-bottom: 15px; position: relative; }
        label { display: block; font-size: 0.8rem; color: #666; margin-bottom: 5px; font-weight: 500; }
        .input-row { display: flex; gap: 8px; align-items: center; }
        input[type=range] { flex: 1; height: 5px; background: #ddd; -webkit-appearance: none; appearance: none; border-radius: 5px; outline: none; }
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 20px; height: 20px; background: var(--primary); border-radius: 50%; cursor: pointer; border: 3px solid white; box-shadow: 0 1px 4px rgba(0,0,0,0.3); }
        input[type=range]::-moz-range-thumb { width: 20px; height: 20px; background: var(--primary); border-radius: 50%; cursor: pointer; border: 3px solid white; box-shadow: 0 1px 4px rgba(0,0,0,0.3); }
        
        input[type=number], select { width: 70px; padding: 8px; border: 1px solid #ccc; border-radius: 6px; font-size: 0.9rem; text-align: center; background: #f8f9fa; }
        select { width: 100%; text-align: left; }
        
        .action-bar { display: flex; gap: 10px; margin-bottom: 15px; }
        .btn-calc { width: 100%; padding: 12px; background: var(--primary); color: white; border: none; border-radius: 8px; font-weight: bold; font-size: 1rem; cursor: pointer; }
        .btn-calc.secondary { background: #007bff; }
        .btn-calc:active { transform: translateY(1px); }

        #slider-tooltip {
            position: fixed;
            background: #333;
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.8rem;
            pointer-events: none;
            transform: translate(-50%, -150%);
            display: none;
            z-index: 101;
        }

        #loader { position: fixed; inset: 0; background: white; z-index: 9999; display: flex; justify-content: center; align-items: center; flex-direction: column; }
        .spinner { width: 40px; height: 40px; border: 4px solid #f3f3f3; border-top-color: var(--primary); border-radius: 50%; animation: spin 1s linear infinite; }
        @keyframes spin { to { transform: rotate(360deg); } }
        
        #debug-log { display:none; background: #333; color: #f88; padding: 10px; font-family: monospace; font-size: 0.8rem; margin: 10px; border-radius: 4px; white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="slider-tooltip"></div>
    <div id="loader"><div class="spinner"></div><p style="margin-top:10px; color:#666">Loading Physics...</p></div>

    <div class="app-container">
        <!-- PLOT AREA (now first in source for mobile) -->
        <div class="main-area">
            <!-- V48 UI-REWORK: Sticky header for mobile -->
        <div class="mobile-sticky-header">
            <div id="cheat-sheet-container-sticky">
            </div>
        </div>
        <div id="cheat-sheet-container"> <!-- Keep original for desktop -->
            <div id="cheat-sheet">Initializing Engine...</div>
        </div>

        <div id="debug-log"></div>
            <div id="plot-area"></div>
        </div>

        <!-- SIDEBAR -->
        <div class="sidebar">
            <!-- V51 ACTION BAR MOVE -->
            <div class="action-bar">
                <button id="btn-auto" class="btn-calc">‚ö° Auto-Optimize</button>
                <button id="btn-update" class="btn-calc secondary">Update Graph</button>
            </div>
            <div class="action-bar">
                <button id="btn-save" class="btn-calc" style="background:#17a2b8; font-size:0.9rem;">üíæ Save Pattern</button>
                <button id="btn-load" class="btn-calc" style="background:#6c757d; font-size:0.9rem;">üìÇ Load Pattern</button>
            </div>
            <!-- V48 UI-REWORK: Tabs -->
            <div class="tabs">
                <button class="tab-button active" data-tab="gear">Gear & Targets</button>
                <button class="tab-button" data-tab="manual">Manual Tweaks</button>
                <button class="tab-button" data-tab="strategy">Colour Strategy</button>
            </div>

            <!-- V48 UI-REWORK: Tab Content -->
            <div id="gear-tab" class="tab-content active">
                <div class="widget-card">
                    <div class="control-group">
                        <label>Line Type</label>
                        <select id="w_line">
                            <option value="Ester">Ester</option>
                            <option value="PE (Braid)">PE (Braid)</option>
                            <option value="Fluorocarbon">Fluorocarbon</option>
                            <option value="Nylon">Nylon</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Leader</label>
                        <select id="w_leader">
                            <option value="Fluorocarbon">Fluorocarbon</option>
                            <option value="Nylon">Nylon</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Lure Model</label>
                        <select id="w_shape">
                            <option value="Generic Standard">Generic Standard</option>
                            <option value="Rodio Craft NOA">Rodio Craft NOA</option>
                            <option value="Forest MIU">Forest MIU</option>
                            <option value="Forest Factor">Forest Factor</option>
                            <option value="Jackall Tearo">Jackall Tearo</option>
                            <option value="Rodio Craft Jeckyll">Rodio Craft Jeckyll</option>
                            <option value="Generic Wide (High Lift)">Generic Wide</option>
                            <option value="Generic Slim (Low Lift)">Generic Slim</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Weight (g)</label>
                        <div class="input-row">
                            <input type="range" id="s_weight" min="0.5" max="5.0" step="0.1" value="1.5" oninput="i_weight.value=this.value">
                            <input type="number" id="i_weight" value="1.5" step="0.1" oninput="s_weight.value=this.value">
                        </div>
                    </div>
                    <div class="control-group">
                        <label>Line Dia (mm)</label>
                        <div class="input-row">
                            <input type="range" id="s_dia" min="0.04" max="0.20" step="0.01" value="0.10" oninput="i_dia.value=this.value">
                            <input type="number" id="i_dia" value="0.10" step="0.01" oninput="s_dia.value=this.value">
                        </div>
                    </div>
                    <div class="control-group">
                        <label>Cast Dist (m)</label>
                        <div class="input-row">
                            <input type="range" id="s_dist" min="10" max="50" step="1" value="20" oninput="i_dist.value=this.value">
                            <input type="number" id="i_dist" value="20" step="1" oninput="s_dist.value=this.value">
                        </div>
                    </div>
                    <div class="control-group">
                        <label>Target Depth (m)</label>
                        <div class="input-row">
                            <input type="range" id="s_target" min="0.5" max="5.0" step="0.1" value="2.0" oninput="i_target.value=this.value">
                            <input type="number" id="i_target" value="2.0" step="0.1" oninput="s_target.value=this.value">
                        </div>
                    </div>
                    <div class="control-group">
                        <label>Pond Depth (m)</label>
                        <div class="input-row">
                            <input type="range" id="s_pond" min="1.5" max="5.0" step="0.5" value="3.0" oninput="i_pond.value=this.value">
                            <input type="number" id="i_pond" value="3.0" step="0.5" oninput="s_pond.value=this.value">
                        </div>
                    </div>
                    <div class="control-group">
                        <label>Reel (cm/turn)</label>
                        <div class="input-row">
                            <input type="range" id="s_reel" min="50" max="90" step="1" value="64" oninput="i_reel.value=this.value">
                            <input type="number" id="i_reel" value="64" step="1" oninput="s_reel.value=this.value">
                        </div>
                    </div>
                    <div class="control-group">
                        <label>Wind Condition</label>
                        <select id="w_wind">
                            <option value="Calm">Calm</option>
                            <option value="Breeze">Light Breeze</option>
                            <option value="Strong">Strong Wind</option>
                        </select>
                    </div>
                </div>
            </div>

            <div id="manual-tab" class="tab-content">
                <div class="widget-card">
                    <div class="control-group">
                        <label>Start Speed (cm/s)</label>
                        <div class="input-row">
                            <input type="range" id="s_spd_s" min="20" max="140" step="5" value="70" oninput="i_spd_s.value=this.value">
                            <input type="number" id="i_spd_s" value="70" step="5" oninput="s_spd_s.value=this.value">
                        </div>
                    </div>
                    <div class="control-group">
                        <label>End Speed (cm/s)</label>
                        <div class="input-row">
                            <input type="range" id="s_spd_e" min="10" max="100" step="5" value="35" oninput="i_spd_e.value=this.value">
                            <input type="number" id="i_spd_e" value="35" step="5" oninput="s_spd_e.value=this.value">
                        </div>
                    </div>
                    <div style="margin: 15px 0; font-size:0.9rem;">
                        <input type="checkbox" id="w_rod_dyn" style="width:20px; height:20px; vertical-align:middle;">
                        <label style="display:inline; vertical-align:middle;">Dynamic Rod Move?</label>
                    </div>
                    <div class="control-group">
                        <label>Rod Start Height (m)</label>
                        <div class="input-row">
                            <input type="range" id="s_rod_s" min="0" max="3.5" step="0.1" value="1.5" oninput="i_rod_s.value=this.value">
                            <input type="number" id="i_rod_s" value="1.5" step="0.1" oninput="s_rod_s.value=this.value">
                        </div>
                    </div>
                    <div class="control-group">
                        <label>Rod End Height (m)</label>
                        <div class="input-row">
                            <input type="range" id="s_rod_e" min="0" max="3.5" step="0.1" value="0.0" oninput="i_rod_e.value=this.value">
                            <input type="number" id="i_rod_e" value="0.0" step="0.1" oninput="s_rod_e.value=this.value">
                        </div>
                    </div>
                    <div class="control-group">
                        <label>Start Reel Depth (m)</label>
                        <div class="input-row">
                            <input type="range" id="s_start_d" min="0.5" max="5.0" step="0.1" value="2.5" oninput="i_start_d.value=this.value">
                            <input type="number" id="i_start_d" value="2.5" step="0.1" oninput="s_start_d.value=this.value">
                        </div>
                    </div>
                    <div class="control-group">
                        <label>Trigger Dist (m)</label>
                        <div class="input-row">
                            <input type="range" id="s_trig" min="0" max="40" step="1" value="15" oninput="i_trig.value=this.value">
                            <input type="number" id="i_trig" value="15" step="1" oninput="s_trig.value=this.value">
                        </div>
                    </div>

                    <hr style="margin: 20px 0; border: 0; border-top: 2px solid #e0e0e0;">
                    <div style="margin: 15px 0; font-size:0.9rem; background: #fff3cd; padding: 8px; border-radius: 4px;">
                        <input type="checkbox" id="w_pause_enable" style="width:20px; height:20px; vertical-align:middle;">
                        <label style="display:inline; vertical-align:middle; font-weight:bold;">Enable Pause-and-Drop</label>
                    </div>

                    <div class="control-group">
                        <label>Pause Duration (sec)</label>
                        <div class="input-row">
                            <input type="range" id="s_pause_dur" min="0.5" max="3.0" step="0.5" value="1.0" oninput="i_pause_dur.value=this.value">
                            <input type="number" id="i_pause_dur" value="1.0" step="0.5" oninput="s_pause_dur.value=this.value">
                        </div>
                    </div>
                    <div class="control-group">
                        <label>Number of Pauses</label>
                        <div class="input-row">
                            <input type="range" id="s_pause_count" min="1" max="3" step="1" value="1" oninput="i_pause_count.value=this.value">
                            <input type="number" id="i_pause_count" value="1" step="1" oninput="s_pause_count.value=this.value">
                        </div>
                    </div>
                    <div class="control-group">
                        <label>First Pause at (m)</label>
                        <div class="input-row">
                            <input type="range" id="s_pause_dist" min="5" max="35" step="1" value="15" oninput="i_pause_dist.value=this.value">
                            <input type="number" id="i_pause_dist" value="15" step="1" oninput="s_pause_dist.value=this.value">
                        </div>
                    </div>
                </div>
            </div>
            
            <div id="strategy-tab" class="tab-content">
                <div class="widget-card">
                    <div id="color-strategy-plan"></div>
                    <div class="control-group">
                        <label>Water Clarity</label>
                        <select id="w_clarity">
                            <option value="Clear">Clear (3+ m vis)</option>
                            <option value="Stained">Stained (1-3m vis)</option>
                            <option value="Turbid">Turbid (<1m vis)</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Light Condition</label>
                        <select id="w_light">
                            <option value="Bright">Bright Sun</option>
                            <option value="Overcast">Overcast / Low Light</option>
                            <option value="Dusk/Dawn">Dusk / Dawn</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Water Color</label>
                        <select id="w_water_color">
                            <option value="Clear">Clear (Blue Tint)</option>
                            <option value="Stained">Stained (Tea/Brown Tint)</option>
                            <option value="Algae">Algae (Green Tint)</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Bottom Type</label>
                        <select id="w_bottom">
                            <option value="Sand">Sand/Light Gravel</option>
                            <option value="Mud">Mud/Silt (Dark)</option>
                            <option value="Weedbed">Weedbed (Green)</option>
                        </select>
                    </div>
                    <div id="color-preview-container"></div>
                </div>
            </div>
        </div>
    </div>

    <py-config>
        packages = ["matplotlib", "numpy"]
    </py-config>

    <py-script>
import matplotlib.pyplot as plt
import matplotlib.patches as patches
import numpy as np
import traceback
from js import document, window
from pyodide.ffi import create_proxy

# --- PHYSICS CONSTANTS ---
PHYSICS = {
    'gravity_scale': 0.28, 'lift_scale': 0.22, 'drag_scale': 0.04,
    'buoyancy_scale': 0.05, 'belly_tuning': 0.20, 'leader_lift': 0.015,
    'flutter_scale': 0.15, 'vortex_scale': 0.08, 'water_density': 1000.0
}

# Lure physical properties (volume in cm¬≥, density relative to water, cross-section in cm¬≤)
LURE_PROPERTIES = {
    'weight_to_volume': 0.8,  # cm¬≥ per gram (typical spoon density ~1.25 g/cm¬≥)
    'lure_density_ratio': 1.25,  # relative to water
    'area_factor': 0.6  # frontal area factor (cm¬≤ per gram^0.66)
}

# Performance optimization - result caching
_physics_cache = {}
_cache_hits = 0
_cache_misses = 0

def log_error(e):
    el = document.getElementById("debug-log")
    el.style.display = "block"
    el.innerHTML = f"PYTHON ERROR: {str(e)}"
    print(f"ERROR: {e}")

def calculate_physics_data(dist, actual_start_depth, line, diameter_mm, leader,
                           rod_start, rod_end, rod_dynamic, rod_move_dist,
                           speed_start, speed_end, decel_dist,
                           weight, shape_profile,
                           steps=150, bottom_limit=-3.0,
                           pause_enabled=False, pause_duration=1.0, pause_count=1, pause_start_dist=15.0):

    global _physics_cache, _cache_hits, _cache_misses

    # Create cache key from input parameters (rounded for better hit rate)
    cache_key = (
        round(dist, 1), round(actual_start_depth, 1), line, round(diameter_mm, 2), leader,
        round(rod_start, 1), round(rod_end, 1), rod_dynamic, round(rod_move_dist, 1),
        round(speed_start, 0), round(speed_end, 0), round(decel_dist, 1),
        round(weight, 1), shape_profile, steps, round(bottom_limit, 1),
        pause_enabled, round(pause_duration, 1), pause_count, round(pause_start_dist, 1)
    )

    # Check cache
    if cache_key in _physics_cache:
        _cache_hits += 1
        return _physics_cache[cache_key]

    _cache_misses += 1

    # Limit cache size to prevent memory issues
    if len(_physics_cache) > 100:
        # Remove oldest entries (simple FIFO)
        _physics_cache.pop(next(iter(_physics_cache)))

    line_props = {
        "PE (Braid)":    {"sg": 0.97, "cd": 1.6, "belly": 2.2, "color": "green"}, 
        "Ester":         {"sg": 1.38, "cd": 1.0, "belly": 0.3, "color": "darkorange"},
        "Nylon":         {"sg": 1.14, "cd": 1.1, "belly": 1.0, "color": "red"}, 
        "Fluorocarbon":  {"sg": 1.78, "cd": 0.9, "belly": -0.6, "color": "blue"}
    }
    leader_props = {"Nylon": 0.05, "Fluorocarbon": -0.05} # Leader AoA effect
    shape_map = {
        "Rodio Craft NOA":     {"Cl": 1.6, "Stall": 15, "SinkFactor": 0.8, "AoA_Sens": 0.6,
                                "Flutter_Freq": 12, "Drag_Coeff": 0.35, "Wobble_Amp": 0.8},
        "Forest MIU":          {"Cl": 1.0, "Stall": 28, "SinkFactor": 1.0, "AoA_Sens": 1.0,
                                "Flutter_Freq": 8, "Drag_Coeff": 0.40, "Wobble_Amp": 1.2},
        "Forest Factor":       {"Cl": 1.2, "Stall": 22, "SinkFactor": 0.85, "AoA_Sens": 0.9,
                                "Flutter_Freq": 10, "Drag_Coeff": 0.38, "Wobble_Amp": 1.0},
        "Jackall Tearo":       {"Cl": 1.1, "Stall": 25, "SinkFactor": 0.9, "AoA_Sens": 1.1,
                                "Flutter_Freq": 9, "Drag_Coeff": 0.42, "Wobble_Amp": 0.9},
        "Rodio Craft Jeckyll": {"Cl": 0.6, "Stall": 22, "SinkFactor": 1.2, "AoA_Sens": 0.8,
                                "Flutter_Freq": 6, "Drag_Coeff": 0.32, "Wobble_Amp": 0.5},
        "Generic Wide (High Lift)":    {"Cl": 1.4, "Stall": 15, "SinkFactor": 0.6, "AoA_Sens": 1.8,
                                        "Flutter_Freq": 14, "Drag_Coeff": 0.50, "Wobble_Amp": 1.5},
        "Generic Standard":            {"Cl": 1.0, "Stall": 25, "SinkFactor": 1.0, "AoA_Sens": 1.0,
                                        "Flutter_Freq": 10, "Drag_Coeff": 0.40, "Wobble_Amp": 1.0},
        "Generic Slim (Low Lift)":     {"Cl": 0.5, "Stall": 35, "SinkFactor": 1.3, "AoA_Sens": 0.5,
                                        "Flutter_Freq": 5, "Drag_Coeff": 0.28, "Wobble_Amp": 0.3},
    }
    
    props = line_props[line]
    spoon_data = shape_map[shape_profile]
    spoon_cl = spoon_data["Cl"]
    stall_threshold = spoon_data["Stall"]
    sink_factor = spoon_data["SinkFactor"]
    aoa_sensitivity = spoon_data["AoA_Sens"]
    flutter_freq = spoon_data["Flutter_Freq"]
    drag_coeff = spoon_data["Drag_Coeff"]
    wobble_amp = spoon_data["Wobble_Amp"]

    x = np.linspace(dist, 0, steps)
    dx = dist / steps
    y = []
    speeds = []
    rod_heights = []
    spoon_angles = []
    is_stalled = []
    flutter_quality = []  # Track flutter/wobble quality
    pause_points = []  # Track pause locations for visualization
    initial_geometry = {}

    current_depth = -abs(actual_start_depth)

    # Calculate pause points if enabled
    pause_distances = []
    pause_active_until_step = {}  # Maps step index to when pause ends

    if pause_enabled and pause_count > 0:
        # Distribute pauses evenly throughout the retrieve
        if pause_count == 1:
            pause_distances = [pause_start_dist]
        else:
            # Space multiple pauses evenly
            spacing = (pause_start_dist - 5) / max(1, pause_count - 1)
            pause_distances = [pause_start_dist - (i * spacing) for i in range(pause_count)]

    # Enhanced lure physics
    lure_volume = weight * LURE_PROPERTIES['weight_to_volume']  # cm¬≥
    lure_cross_area = LURE_PROPERTIES['area_factor'] * (weight ** 0.66)  # cm¬≤
    term_velocity = PHYSICS['gravity_scale'] * np.sqrt(weight / 1.5)
    effective_sink_rate = term_velocity * sink_factor
    area_lift_scaler = (weight / 1.5) ** 0.7
    dia_scale_drag = (diameter_mm / 0.10)
    dia_scale_vol = (diameter_mm / 0.10) ** 2

    # Proper lure buoyancy force (constant)
    lure_buoyancy_force = PHYSICS['buoyancy_scale'] * lure_volume * (1.0 - LURE_PROPERTIES['lure_density_ratio'])

    # Track time elapsed during pauses (for physics calculation)
    pause_time_tracker = 0.0

    for i, d in enumerate(x):
        # Check if we're in a pause
        in_pause = False
        if pause_enabled:
            # Check if current distance triggers a new pause
            for pause_dist in pause_distances:
                if abs(d - pause_dist) < (dx / 2) and i not in pause_active_until_step:
                    # Start pause - calculate how many steps it lasts
                    # Each step represents dx meters traveled at current speed
                    # During pause, we simulate free-fall for pause_duration seconds
                    pause_active_until_step[i] = i + int(pause_duration / 0.05)  # ~0.05s per step during pause
                    pause_points.append((d, current_depth))  # Mark pause location

            # Check if currently paused
            if any(start_step <= i < end_step for start_step, end_step in pause_active_until_step.items()):
                in_pause = True
        if current_depth <= bottom_limit:
            remaining = steps - i
            y.extend([bottom_limit] * remaining)
            speeds.extend([0] * remaining)
            rod_heights.extend([rod_end if rod_dynamic else rod_start] * remaining)
            spoon_angles.extend([0] * remaining)
            is_stalled.extend([True] * remaining)
            flutter_quality.extend([0.0] * remaining)
            break
            
        if d < 0.2:
            y.append(0); speeds.append(0); is_stalled.append(True); rod_heights.append(rod_start); spoon_angles.append(0); flutter_quality.append(0.0)
            continue
            
        if rod_dynamic:
            if d > rod_move_dist: r_h = rod_start
            else:
                ratio_rod = 0 if rod_move_dist == 0 else d / rod_move_dist
                r_h = rod_end + ((rod_start - rod_end) * ratio_rod)
        else:
            r_h = rod_start
        
        rod_heights.append(r_h)

        total_drop = r_h + abs(current_depth)
        if total_drop <= 0.001: ratio_air = 0; entry_dist_x = d
        else: ratio_air = r_h / total_drop; entry_dist_x = d * ratio_air
        ratio_in_water = max(0, 1.0 - ratio_air)
        
        if i == 0:
            initial_geometry = {'rod_h': r_h, 'spoon_x': d, 'spoon_y': current_depth, 'entry_x': entry_dist_x}

        # PAUSE-AND-DROP LOGIC
        if in_pause:
            v_cms = 0  # No reeling during pause
            speeds.append(v_cms)
            dt = 0.05  # Fixed timestep during pause (50ms)
        else:
            # Normal speed calculation
            if d > decel_dist: v_cms = speed_start
            else:
                if decel_dist == 0: ratio = 0
                else: ratio = d / decel_dist
                v_cms = speed_end + ((speed_start - speed_end) * ratio)

            speeds.append(v_cms)
            v = max(0.01, v_cms / 100.0)
            dt = dx / v

        dy = r_h - current_depth
        geo_angle = np.arctan(dy / d) if d > 0.01 else 0
        angle_degrees = np.degrees(geo_angle)
        spoon_angles.append(angle_degrees)

        # PAUSE-AND-DROP FLUTTER LOGIC
        if in_pause:
            # During pause: no flutter, complete stall
            is_stalled.append(True)
            cl_effective = 0.0  # No lift during pause
            flutter_q = 0.0
        else:
            # Check if we just resumed from pause (trigger effect!)
            just_resumed = False
            if i > 0 and pause_enabled:
                # Check if previous step was in pause
                prev_in_pause = any(start_step <= (i-1) < end_step for start_step, end_step in pause_active_until_step.items())
                if prev_in_pause and not in_pause:
                    just_resumed = True

            # Realistic stall behavior with hysteresis
            stall_speed = stall_threshold * 0.7  # Speed below which stall is guaranteed
            recovery_speed = stall_threshold * 1.2  # Speed needed to recover from stall

            if v_cms < stall_speed or abs(angle_degrees) > 45:
                # Complete stall - catastrophic loss of lift
                is_stalled.append(True)
                cl_effective = spoon_cl * 0.05  # 95% lift loss
                flutter_q = 0.0
            elif v_cms < stall_threshold:
                # Partial stall - reduced lift, poor action
                is_stalled.append(True)
                stall_ratio = (stall_threshold - v_cms) / (stall_threshold - stall_speed)
                cl_effective = spoon_cl * (0.3 + 0.6 * (1 - stall_ratio))
                flutter_q = 0.2 * (1 - stall_ratio)
            else:
                # Good flow - calculate flutter quality
                is_stalled.append(False)
                cl_effective = spoon_cl

                # Flutter quality depends on speed range and lure characteristics
                optimal_speed = stall_threshold * 2.0
                speed_factor = min(1.0, v_cms / optimal_speed)

                # Wobble induced by vortex shedding
                flutter_phase = (i / steps) * flutter_freq * 2 * np.pi
                wobble_contribution = np.sin(flutter_phase) * wobble_amp * speed_factor
                flutter_q = max(0.0, min(1.0, speed_factor * wobble_amp))

                # TRIGGER EFFECT: Just resumed from pause = maximum flutter!
                if just_resumed:
                    flutter_q = 1.0  # 100% flutter quality spike

        flutter_quality.append(flutter_q)
        
        # PHYSICS FORCES
        if in_pause:
            # FREE-FALL PHYSICS during pause
            delta_rod = 0.0  # No horizontal movement
            delta_lift = 0.0  # No lift (no speed)
            delta_line_drag = 0.0  # Minimal line drag (slack line)
            delta_line_buoy = 0.0  # Line not pulling
            delta_vortex = 0.0  # No vortex shedding

            # Only gravity and lure buoyancy act during pause
            delta_grav = -effective_sink_rate * dt * 1.2  # Slightly faster sink (no resistance)
            delta_lure_buoy = lure_buoyancy_force * dt

            wind_lift = 0.0  # No wind effect during pause
        else:
            # NORMAL RETRIEVE PHYSICS
            leader_aoa_mod = leader_props[leader]

            aoa_factor = 1.0 + (np.sin(geo_angle) * aoa_sensitivity) + leader_aoa_mod
            belly_impact = props['belly'] * (d / 25.0) * PHYSICS['belly_tuning'] * ratio_in_water
            effective_angle_sin = np.sin(geo_angle) + belly_impact

            v = v_cms / 100.0  # Convert cm/s to m/s
            delta_rod = (v * dt) * effective_angle_sin
            delta_grav = -effective_sink_rate * dt

            delta_lift = PHYSICS['lift_scale'] * (v**2) * cl_effective * area_lift_scaler * aoa_factor * dt
            delta_line_drag = PHYSICS['drag_scale'] * props['cd'] * (v**2) * dia_scale_drag * (d/25.0) * dt * ratio_in_water

            # Proper line buoyancy (acts on submerged line)
            delta_line_buoy = PHYSICS['buoyancy_scale'] * (1.0 - props['sg']) * dia_scale_vol * (d/25.0) * dt * ratio_in_water

            # Proper lure buoyancy (constant, negative for sinking lures)
            delta_lure_buoy = lure_buoyancy_force * dt * ratio_in_water

            # Vortex shedding drag (reduces depth oscillation, adds realism)
            delta_vortex = PHYSICS['vortex_scale'] * (v**2) * drag_coeff * flutter_q * dt * ratio_in_water

            wind_factor = {'Calm': 0.0, 'Breeze': 0.005, 'Strong': 0.02}
            wind_lift = wind_factor.get(get_val("w_wind"), 0.0) * (d / dist) * ratio_air * dt

        current_depth += (delta_rod + delta_grav + delta_lift + delta_line_drag +
                         delta_line_buoy + delta_lure_buoy + delta_vortex + wind_lift)
        if current_depth > 0: current_depth = 0
        y.append(current_depth)

    # Cache result before returning
    result = (x, y, speeds, props['color'], initial_geometry, rod_heights, spoon_angles, flutter_quality, pause_points)
    _physics_cache[cache_key] = result

    return result

# --- ADVANCED OPTIMIZER ---
def calculate_advanced_score(y, speeds, flutter_quality, target_depth, pond_bottom, spd_s, r_s, wind):
    """Calculate comprehensive score based on multiple factors"""
    min_depth = np.min(y)

    # Instant fail if hitting bottom
    if min_depth <= (pond_bottom + 0.1):
        return -5000

    target = -target_depth
    tolerance = 0.3

    # 1. Time in target zone (40% weight)
    in_zone = [val for val in y if abs(val - target) <= tolerance]
    time_in_zone_score = (len(in_zone) / len(y)) * 100

    # 2. Flutter quality (20% weight) - higher is better
    avg_flutter = np.mean(flutter_quality) if len(flutter_quality) > 0 else 0
    flutter_score = avg_flutter * 100

    # 3. Depth stability (20% weight) - less variance is better
    depth_variance = np.std(y) if len(y) > 1 else 0
    stability_score = max(0, 100 - (depth_variance * 50))

    # 4. Fish trigger probability (20% weight)
    # Fish prefer: moderate speed, good flutter, consistent depth
    avg_speed = np.mean(speeds) if len(speeds) > 0 else 0
    optimal_speed = 60  # cm/s - typical reactive speed for trout
    speed_factor = max(0, 100 - abs(avg_speed - optimal_speed))
    fish_trigger_score = (speed_factor * 0.5) + (flutter_score * 0.5)

    # Combined score
    total_score = (time_in_zone_score * 0.4 +
                   flutter_score * 0.2 +
                   stability_score * 0.2 +
                   fish_trigger_score * 0.2)

    # Penalties
    total_score -= (spd_s * 0.15)  # Slightly penalize high speeds (energy waste)

    if wind == "Strong" and r_s > 0.5:
        total_score -= 50  # Heavy penalty for high rod in wind

    return total_score


def optimize_technique(dist, target_depth, weight, shape, diameter, leader, line, pond_bottom):
    best_score = -99999
    best_params = {}

    # EXPANDED SPEED PROFILES - including pulsing, pause, acceleration patterns
    base_profiles = []
    if weight >= 2.0:
        if line == "PE (Braid)":
            base_profiles = [(80, 50), (70, 40), (60, 30), (90, 60), (50, 20)]  # Added slow option
        else:
            base_profiles = [(120, 80), (100, 70), (90, 60), (80, 50), (70, 40), (60, 30)]
    elif weight >= 1.2:
        if "Slim" in shape or "Jeckyll" in shape:
            base_profiles = [(80, 60), (70, 50), (90, 70), (60, 40), (50, 30)]
        else:
            base_profiles = [(70, 40), (60, 30), (50, 25), (80, 50), (40, 20)]
    else:
        if line == "PE (Braid)":
            base_profiles = [(40, 15), (30, 15), (50, 25), (35, 10)]
        else:
            base_profiles = [(50, 20), (40, 20), (30, 15), (60, 30), (35, 10)]

    # ACCELERATION PROFILES (start slow, end fast - opposite pattern)
    accel_profiles = [(start * 0.6, end * 1.3) for start, end in base_profiles[:3]]

    all_speed_profiles = base_profiles + accel_profiles

    # EXPANDED ROD OPTIONS - including pumping patterns
    rod_opts = [
        (1.5, 0.0, True),   # Classic drop
        (0.0, 0.0, False),  # Static low
        (2.5, 0.5, True),   # High start, medium drop
        (1.0, 0.0, True),   # Medium drop
    ]

    # MORE START DEPTH OPTIONS
    start_depths = [
        target_depth,
        min(target_depth + 0.5, abs(pond_bottom) - 0.2),
        max(target_depth - 0.3, 0.5)
    ]

    # EXPANDED TRIGGER POINTS (6 options instead of 2)
    trigger_percentages = [0.3, 0.5, 0.6, 0.7, 0.8, 0.9]

    # PAUSE-AND-DROP OPTIONS
    pause_options = [
        (False, 1.0, 1, dist * 0.5),  # No pause
        (True, 1.0, 1, dist * 0.6),   # 1 pause, 1 second, mid-retrieve
        (True, 1.5, 1, dist * 0.7),   # 1 pause, 1.5 seconds, late retrieve
        (True, 1.0, 2, dist * 0.7),   # 2 pauses
    ]

    wind = get_val("w_wind")

    # Test all combinations
    for spd_s, spd_e in all_speed_profiles:
        for r_s, r_e, r_dyn in rod_opts:
            for s_depth in start_depths:
                for trig_pct in trigger_percentages:
                    trigger_dist = dist * trig_pct

                    for pause_en, pause_dur, pause_cnt, pause_start in pause_options:
                        x, y, speeds, _, _, _, _, flutter_q, _ = calculate_physics_data(
                            dist, s_depth, line, diameter, leader, r_s, r_e, r_dyn, trigger_dist,
                            spd_s, spd_e, trigger_dist, weight, shape,
                            steps=30, bottom_limit=pond_bottom,
                            pause_enabled=pause_en, pause_duration=pause_dur,
                            pause_count=pause_cnt, pause_start_dist=pause_start
                        )

                        score = calculate_advanced_score(y, speeds, flutter_q, target_depth,
                                                         pond_bottom, spd_s, r_s, wind)

                        if score > best_score:
                            best_score = score
                            best_params = {
                                'spd_s': spd_s, 'spd_e': spd_e,
                                'rod_s': r_s, 'rod_e': r_e, 'rod_dyn': r_dyn,
                                'start_depth': s_depth, 'trigger_dist': trigger_dist,
                                'pause_enabled': pause_en, 'pause_duration': pause_dur,
                                'pause_count': pause_cnt, 'pause_dist': pause_start,
                                'score': score
                            }

    return best_params

# --- DOM HELPERS ---
def get_val(id):
    el = document.getElementById(id)
    if el.type == "checkbox": return el.checked
    if el.type == "number" or el.type == "range": return float(el.value)
    return el.value

def set_val(id, val):
    el = document.getElementById(id)
    if "s_" in id:
        document.getElementById(id).value = val
        document.getElementById(id.replace("s_", "i_")).value = val
    elif "i_" in id:
        document.getElementById(id).value = val
        document.getElementById(id.replace("i_", "s_")).value = val
    else: el.value = val
    if el.type == "checkbox": el.checked = val

# --- MAIN PLOT ---
def update_plot(event=None):
    try:
        line = get_val("w_line"); leader = get_val("w_leader"); shape = get_val("w_shape")
        weight = get_val("s_weight"); dia = get_val("s_dia"); reel_cm = int(get_val("s_reel"))
        dist = get_val("s_dist"); target_depth = get_val("s_target"); pond_depth = get_val("s_pond")
        start_depth = get_val("s_start_d"); trigger = get_val("s_trig")
        spd_s = get_val("s_spd_s"); spd_e = get_val("s_spd_e")
        rod_dyn = get_val("w_rod_dyn"); rod_s = get_val("s_rod_s"); rod_e = get_val("s_rod_e")
        p_bot = -pond_depth
        
        water_color_name = get_val("w_water_color")
        bottom_name = get_val("w_bottom")
        palette = get_palette(water_color_name, bottom_name)

        # Get pause parameters
        pause_enabled = get_val("w_pause_enable")
        pause_duration = get_val("s_pause_dur")
        pause_count = int(get_val("s_pause_count"))
        pause_dist = get_val("s_pause_dist")

        x, y, speeds, color, init_geo, rod_heights, angles, flutter_q, pause_pts = calculate_physics_data(
            dist, start_depth, line, dia, leader, rod_s, rod_e, rod_dyn, trigger,
            spd_s, spd_e, trigger, weight, shape, steps=150, bottom_limit=p_bot,
            pause_enabled=pause_enabled, pause_duration=pause_duration,
            pause_count=pause_count, pause_start_dist=pause_dist
        )

        is_mobile = window.innerWidth < 900
        plot_div = document.getElementById("plot-area")
        px_width = plot_div.clientWidth
        
        fig_width_in = px_width / 100.0
        fig_height_in = fig_width_in * 1.2 if is_mobile else fig_width_in * 0.6
        
        plt.close('all')
        fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(fig_width_in, fig_height_in), dpi=100, gridspec_kw={'height_ratios': [3, 1]})

        if is_mobile: plt.subplots_adjust(left=0.08, right=0.99, bottom=0.08, top=0.95)
        else: plt.subplots_adjust(left=0.08, right=0.95, bottom=0.1, top=0.95)

        ax1.add_patch(patches.Rectangle((-5, p_bot - 2), 60, p_bot + 9, color=palette['water'], alpha=0.2))
        ax1.add_patch(patches.Rectangle((0, -target_depth-0.3), dist+4, 0.6, color=palette['target'], alpha=0.3, label='Target'))
        ax1.axhline(0, color='dodgerblue', linewidth=2)
        ax1.axhline(p_bot, color=palette['bottom'], linewidth=3)
        
        ax1.plot(x, y, color=color, linewidth=3, label=line)
        ax1.axvline(trigger, color='purple', linestyle='--', alpha=0.5)

        # Mark pause points
        if pause_enabled and len(pause_pts) > 0:
            pause_x = [p[0] for p in pause_pts]
            pause_y = [p[1] for p in pause_pts]
            ax1.scatter(pause_x, pause_y, color='red', s=150, marker='X', zorder=10, label='Pause', edgecolors='black', linewidths=2)
        
        rod_wrist_x = -1.2; rod_wrist_y = 1.0
        ax1.add_patch(patches.Rectangle((-3, -0.5), 3, 0.5, color=palette['land'], alpha=0.6)) # Land
        ax1.plot([-1.5, -1.5], [0.8, 1.5], 'k', lw=3)
        ax1.plot([-1.8, -1.5, -1.2], [0, 0.8, 0], 'k', lw=2)
        ax1.add_patch(patches.Circle((-1.5, 1.75), 0.25, color='k'))
        ax1.plot([-1.5, rod_wrist_x], [1.3, rod_wrist_y], 'k', lw=3)
        ax1.plot([rod_wrist_x, 0], [rod_wrist_y, rod_s], 'k', lw=3)
        if rod_dyn: ax1.plot([rod_wrist_x, 0], [rod_wrist_y, rod_e], 'gray', ls=':')
            
        if init_geo:
            ax1.plot([0, init_geo['entry_x']], [init_geo['rod_h'], 0], 'gray', ls='--', lw=1)
            ax1.plot([init_geo['entry_x'], init_geo['spoon_x']], [0, init_geo['spoon_y']], 'gray', ls='-', lw=1)

        ax1.set_ylim(-4.5, 2.5); ax1.set_xlim(dist+3, -3)
        ax1.set_ylabel(""); ax1.legend(loc='upper left', fontsize='small')
        ax1.grid(True, alpha=0.5, ls='--')
        
        ax2.plot(x, speeds, color='purple', lw=2, label="Speed")
        ax2.set_ylim(0, 150); ax2.set_yticks([]) 
        ax3 = ax2.twinx()
        ax3.plot(x, rod_heights, color='brown', ls='-.', lw=2, label="Rod")
        ax3.set_ylim(0, 4.0); ax3.set_yticks([]) 
        ax2.set_xlim(dist+3, -3); ax2.grid(True, alpha=0.3)
        lines_1, labels_1 = ax2.get_legend_handles_labels()
        lines_2, labels_2 = ax3.get_legend_handles_labels()
        ax2.legend(lines_1 + lines_2, labels_1 + labels_2, loc='upper left', fontsize='x-small')
        
        step = 8; q_x = x[::step]; q_y = speeds[::step]
        q_ang = np.array(angles)[::step]; rads = np.radians(q_ang)
        u, v = np.cos(rads), np.sin(rads)
        ax2.quiver(q_x, q_y, u, v, scale=30, width=0.005, headaxislength=0, headlength=0, pivot='mid', color='black')

        cranks_1 = ((dist - trigger) * 100) / reel_cm
        cranks_2 = (trigger * 100) / reel_cm
        rod_action = f"Lower to {rod_e}m" if rod_dyn else f"Hold Steady"

        # Use advanced scoring
        target = -target_depth
        wind = get_val("w_wind")
        total_score = calculate_advanced_score(y, speeds, flutter_q, target_depth, p_bot, spd_s, rod_s, wind)

        # Also calculate individual metrics for display
        in_zone = [val for val in y if abs(val - target) <= 0.3]
        time_in_zone_pct = (len(in_zone) / len(y)) * 100
        avg_flutter = np.mean(flutter_q) if len(flutter_q) > 0 else 0
        flutter_pct = avg_flutter * 100
        
        sheet_html = f'''<div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;">
                         <span style="font-weight:bold; font-size:1.1rem">üéØ Total: {total_score:.0f}</span>
                         <span style="color:#666">Zone: {time_in_zone_pct:.0f}% | Flutter: {flutter_pct:.0f}%</span></div>
                         <hr style="border:0; border-top:1px solid #ccc; margin:5px 0;">
                         1. Cast <b>{dist}m</b>. Sink to <b>{start_depth}m</b>.<br>
                         2. <b>HOLD ROD {rod_s}m.</b> Reel <b>{cranks_1:.1f}x</b> ({int(spd_s)} cm/s)<br>
                         <div style="background-color:#fff3cd; padding:5px; margin:5px 0; border-radius:4px;">
                         <b>‚ö° TRIGGER at {trigger:.0f}m:</b> {rod_action} + Slow ({int(spd_e)} cm/s)</div>
                         4. Reel <b>{cranks_2:.1f}x</b> to finish.'''
        
        clarity = get_val("w_clarity"); light = get_val("w_light")
        all_scores, warnings = recommend_colors(clarity, light, target_depth, bottom_name)
        
        strategy_html = '<div id="color-strategy"><b>Color Strategy:</b><ul style="margin:5px 0 0 15px; padding:0; list-style-type: none;">'
        top_recs = [item for item in all_scores if item[1] > 0][:3]

        for i, (color, score) in enumerate(top_recs):
            reason = "High contrast" if color in ["Black", "White"] else "High visibility"
            if clarity == "Clear" and color in ["Natural", "Silver"]: reason = "Natural imitation"
            if light == "Overcast" and color == "Gold": reason = "Bright in low light"
            if light == "Dusk/Dawn" and color == "Chartreuse": reason = "Fluorescent advantage"
            if target_depth > 3.5 and color == "Blue": reason = "Deep water penetration"
            strategy_html += f'<li><b>{i+1}. {color}:</b> {reason}</li>'
        
        if warnings: strategy_html += '<li style="margin-top:5px;">‚ö†Ô∏è <b>Avoid:</b> ' + ", ".join(warnings) + '</li>'
        strategy_html += '</ul></div>'
        
        final_html = sheet_html
        document.getElementById("cheat-sheet").innerHTML = final_html
        document.getElementById("color-strategy-plan").innerHTML = strategy_html

        sticky_sheet = document.getElementById("cheat-sheet-sticky")
        if sticky_sheet: sticky_sheet.innerHTML = final_html

        update_color_previews(target_depth, clarity, all_scores)

        display(fig, target="plot-area", append=False)
        
    except Exception as e: log_error(e)

# V55 ADVANCED COLOR ENGINE
class Color:
    def __init__(self, name, surface_hex, deep_hex, max_depth_m):
        self.name = name
        self.surface_hex = surface_hex
        self.surface_rgb = tuple(int(surface_hex.lstrip('#')[i:i+2], 16) for i in (0, 2, 4))
        self.deep_rgb = tuple(int(deep_hex.lstrip('#')[i:i+2], 16) for i in (0, 2, 4))
        self.max_depth_m = max_depth_m

    def get_perceived_rgb(self, depth, clarity):
        clarity_factor = {"Clear": 1.0, "Stained": 1.5, "Turbid": 2.5}
        effective_depth = depth * clarity_factor.get(clarity, 1.0)
        absorption_factor = min(1.0, effective_depth / self.max_depth_m)
        r = int(self.surface_rgb[0] * (1 - absorption_factor) + self.deep_rgb[0] * absorption_factor)
        g = int(self.surface_rgb[1] * (1 - absorption_factor) + self.deep_rgb[1] * absorption_factor)
        b = int(self.surface_rgb[2] * (1 - absorption_factor) + self.deep_rgb[2] * absorption_factor)
        return (r, g, b)

    def get_perceived_hex(self, depth, clarity):
        r, g, b = self.get_perceived_rgb(depth, clarity)
        return f'#{r:02x}{g:02x}{b:02x}'

COLOR_PALETTE = [
    Color("Red", "#FF0000", "#301010", 7.5), Color("Orange", "#FFA500", "#302010", 10.0),
    Color("Pink", "#FFC0CB", "#403030", 7.5), Color("Chartreuse", "#DFFF00", "#607000", 20.0),
    Color("Gold", "#FFD700", "#615300", 20.0), Color("Silver", "#C0C0C0", "#80bfff", 30.0),
    Color("Blue", "#0000FF", "#00008B", 33.0), Color("Green", "#008000", "#003000", 24.0),
    Color("White", "#FFFFFF", "#A0A0A0", 30.0), Color("Black", "#000000", "#000000", 30.0),
    Color("Copper", "#B87333", "#4a2f15", 10.0), Color("Natural", "#8B4513", "#4d260a", 15.0)
]

def get_palette(water_color_name, bottom_name):
    return {
        "water": {'Clear': '#d4f1f9', 'Stained': '#e0d8c6', 'Algae': '#d9ead3'}.get(water_color_name, '#d4f1f9'),
        "bottom": {'Sand': '#c2b280', 'Mud': '#594a41', 'Weedbed': '#3b5323'}.get(bottom_name, '#c2b280'),
        "land": "#28a745", "target": "limegreen"
    }

def recommend_colors(clarity, light, depth, bottom):
    scores = {c.name: 0 for c in COLOR_PALETTE}
    if clarity == "Clear": scores["Silver"] += 3; scores["Natural"] += 2; scores["Pink"] += 1
    elif clarity == "Stained": scores["Gold"] += 3; scores["Chartreuse"] += 2; scores["Copper"] += 1
    else: scores["Chartreuse"] += 3; scores["White"] += 2; scores["Black"] += 2
    if light == "Bright": scores["Silver"] += 2; scores["Gold"] += 1
    elif light == "Overcast": scores["Gold"] += 2; scores["Chartreuse"] += 2; scores["White"] += 1
    else: scores["Chartreuse"] += 3; scores["Black"] += 3; scores["White"] += 2
    warnings = []
    for color_obj in COLOR_PALETTE:
        if depth > color_obj.max_depth_m:
            scores[color_obj.name] -= 10
            if color_obj.name not in warnings: warnings.append(color_obj.name)
    if bottom in ["Mud", "Weedbed"]: scores["White"] += 2; scores["Chartreuse"] += 2; scores["Silver"] += 1
    else: scores["Black"] += 3; scores["Copper"] += 1
    return sorted(scores.items(), key=lambda item: item[1], reverse=True), warnings

def update_color_previews(depth, clarity, all_scores):
    preview_container = document.getElementById("color-preview-container")
    html = "<b>Color Previews at Depth</b>"
    score_map = dict(all_scores)
    for color_obj in sorted(COLOR_PALETTE, key=lambda c: score_map.get(c.name, 0), reverse=True):
        perceived_hex = color_obj.get_perceived_hex(depth, clarity)
        score = score_map.get(color_obj.name, 0)
        html += f'''
            <div class="color-swatch">
                <div class="swatch-pair">
                    <div class="swatch" style="background-color:{color_obj.surface_hex};"></div>
                    <div class="swatch" style="background-color:{perceived_hex};"></div>
                </div>
                {color_obj.name} (Score: {score})
            </div>
        '''
    preview_container.innerHTML = html

def run_auto_tune_handler(*args):
    try:
        dist = get_val("s_dist"); target = get_val("s_target"); wt = get_val("s_weight")
        shape = get_val("w_shape"); dia = get_val("s_dia"); leader = get_val("w_leader")
        line = get_val("w_line"); pond = -get_val("s_pond")
        res = optimize_technique(dist, target, wt, shape, dia, leader, line, pond)
        if res:
            set_val("s_spd_s", int(res['spd_s'])); set_val("s_spd_e", int(res['spd_e']))
            set_val("s_rod_s", res['rod_s']); set_val("s_rod_e", res['rod_e'])
            set_val("w_rod_dyn", res['rod_dyn']); set_val("s_start_d", round(res['start_depth'], 1))
            set_val("s_trig", int(res['trigger_dist']))

            # Apply pause settings if found
            if 'pause_enabled' in res:
                set_val("w_pause_enable", res['pause_enabled'])
                set_val("s_pause_dur", res.get('pause_duration', 1.0))
                set_val("s_pause_count", int(res.get('pause_count', 1)))
                set_val("s_pause_dist", int(res.get('pause_dist', 15)))

            update_plot_handler(None)
        else:
            document.getElementById("cheat-sheet").innerHTML = "<b>‚ùå SETUP IMPOSSIBLE. CHANGE GEAR.</b>"
    except Exception as e: log_error(e)

def update_plot_handler(*args):
    update_plot()

# --- V48 UI-REWORK: JAVASCRIPT HELPERS ---
def setup_ui_listeners():
    # Tab switching
    tabs = document.querySelectorAll('.tab-button')
    tab_contents = document.querySelectorAll('.tab-content')
    def switch_tab(e):
        for tab in tabs: tab.classList.remove('active')
        e.target.classList.add('active')
        for content in tab_contents: content.classList.remove('active')
        document.getElementById(e.target.dataset.tab + '-tab').classList.add('active')
    for tab in tabs:
        tab.addEventListener('click', create_proxy(switch_tab))

    # Slider tooltip
    sliders = document.querySelectorAll('input[type=range]')
    tooltip = document.getElementById('slider-tooltip')
    def show_tooltip(e):
        tooltip.style.display = 'block'
        update_tooltip(e)
    def hide_tooltip(e):
        tooltip.style.display = 'none'
    def update_tooltip(e):
        slider = e.target
        rect = slider.getBoundingClientRect()
        thumb_pos = (slider.value - slider.min) / (slider.max - slider.min)
        px_pos = rect.left + (thumb_pos * rect.width)
        tooltip.style.left = f'{px_pos}px'
        tooltip.style.top = f'{rect.top}px'
        tooltip.innerHTML = slider.value
    for slider in sliders:
        slider.addEventListener('input', create_proxy(update_tooltip))
        slider.addEventListener('mousedown', create_proxy(show_tooltip))
        slider.addEventListener('mouseup', create_proxy(hide_tooltip))
        slider.addEventListener('touchstart', create_proxy(show_tooltip))
        slider.addEventListener('touchend', create_proxy(hide_tooltip))

# --- PATTERN LIBRARY (Save/Load) ---
def save_pattern_handler(*args):
    try:
        # Get current configuration
        pattern = {
            'name': '',
            'line': get_val("w_line"),
            'leader': get_val("w_leader"),
            'shape': get_val("w_shape"),
            'weight': get_val("s_weight"),
            'dia': get_val("s_dia"),
            'dist': get_val("s_dist"),
            'target': get_val("s_target"),
            'pond': get_val("s_pond"),
            'reel': get_val("s_reel"),
            'wind': get_val("w_wind"),
            'spd_s': get_val("s_spd_s"),
            'spd_e': get_val("s_spd_e"),
            'rod_s': get_val("s_rod_s"),
            'rod_e': get_val("s_rod_e"),
            'rod_dyn': get_val("w_rod_dyn"),
            'start_d': get_val("s_start_d"),
            'trig': get_val("s_trig"),
            'pause_enable': get_val("w_pause_enable"),
            'pause_dur': get_val("s_pause_dur"),
            'pause_count': get_val("s_pause_count"),
            'pause_dist': get_val("s_pause_dist")
        }

        # Prompt for name
        pattern_name = window.prompt("Enter pattern name:", "My Retrieve")
        if pattern_name:
            pattern['name'] = pattern_name

            # Get existing patterns from localStorage
            import json
            stored = window.localStorage.getItem('trout_patterns')
            patterns = json.loads(stored) if stored else []

            # Add new pattern
            patterns.append(pattern)

            # Save back to localStorage
            window.localStorage.setItem('trout_patterns', json.dumps(patterns))

            window.alert(f"‚úÖ Pattern '{pattern_name}' saved!")
    except Exception as e:
        log_error(e)


def load_pattern_handler(*args):
    try:
        import json
        stored = window.localStorage.getItem('trout_patterns')

        if not stored:
            window.alert("No saved patterns found!")
            return

        patterns = json.loads(stored)

        if len(patterns) == 0:
            window.alert("No saved patterns found!")
            return

        # Create selection list
        pattern_list = "\n".join([f"{i+1}. {p.get('name', 'Unnamed')}" for i, p in enumerate(patterns)])
        selection = window.prompt(f"Select pattern number:\n\n{pattern_list}\n\nOr type 'delete X' to remove pattern X", "1")

        if not selection:
            return

        # Handle delete command
        if selection.lower().startswith('delete '):
            try:
                idx = int(selection.split()[1]) - 1
                if 0 <= idx < len(patterns):
                    deleted = patterns.pop(idx)
                    window.localStorage.setItem('trout_patterns', json.dumps(patterns))
                    window.alert(f"üóëÔ∏è Deleted: {deleted.get('name', 'Unnamed')}")
                else:
                    window.alert("Invalid pattern number!")
            except:
                window.alert("Invalid delete command! Use: delete 1")
            return

        # Load selected pattern
        try:
            idx = int(selection) - 1
            if 0 <= idx < len(patterns):
                p = patterns[idx]

                # Apply pattern settings
                set_val("w_line", p.get('line', 'Ester'))
                set_val("w_leader", p.get('leader', 'Fluorocarbon'))
                set_val("w_shape", p.get('shape', 'Generic Standard'))
                set_val("s_weight", p.get('weight', 1.5))
                set_val("s_dia", p.get('dia', 0.10))
                set_val("s_dist", p.get('dist', 20))
                set_val("s_target", p.get('target', 2.0))
                set_val("s_pond", p.get('pond', 3.0))
                set_val("s_reel", p.get('reel', 64))
                set_val("w_wind", p.get('wind', 'Calm'))
                set_val("s_spd_s", p.get('spd_s', 70))
                set_val("s_spd_e", p.get('spd_e', 35))
                set_val("s_rod_s", p.get('rod_s', 1.5))
                set_val("s_rod_e", p.get('rod_e', 0.0))
                set_val("w_rod_dyn", p.get('rod_dyn', True))
                set_val("s_start_d", p.get('start_d', 2.5))
                set_val("s_trig", p.get('trig', 15))
                set_val("w_pause_enable", p.get('pause_enable', False))
                set_val("s_pause_dur", p.get('pause_dur', 1.0))
                set_val("s_pause_count", p.get('pause_count', 1))
                set_val("s_pause_dist", p.get('pause_dist', 15))

                update_plot()
                window.alert(f"‚úÖ Loaded: {p.get('name', 'Unnamed')}")
            else:
                window.alert("Invalid pattern number!")
        except:
            window.alert("Invalid selection!")
    except Exception as e:
        log_error(e)


# --- V49 RESIZE FIX ---
_debounce_timer = None
def debounce_update_plot(e=None):
    global _debounce_timer
    if _debounce_timer:
        window.clearTimeout(_debounce_timer)
    _debounce_timer = window.setTimeout(create_proxy(update_plot), 150)

# --- BINDING HELPERS ---
update_proxy = create_proxy(update_plot)
auto_proxy = create_proxy(run_auto_tune_handler)
save_proxy = create_proxy(save_pattern_handler)
load_proxy = create_proxy(load_pattern_handler)
debounce_proxy = create_proxy(debounce_update_plot)

def bind_listeners():
    document.getElementById("btn-auto").addEventListener("click", auto_proxy)
    document.getElementById("btn-update").addEventListener("click", update_proxy)
    document.getElementById("btn-save").addEventListener("click", save_proxy)
    document.getElementById("btn-load").addEventListener("click", load_proxy)
    
    window.addEventListener('resize', debounce_proxy)

    original_container = document.getElementById("cheat-sheet-container")
    sticky_container = document.getElementById("cheat-sheet-container-sticky")
    if original_container and sticky_container:
        original_sheet = original_container.querySelector("#cheat-sheet")
        cloned_sheet = original_sheet.cloneNode(True)
        cloned_sheet.id = "cheat-sheet-sticky"
        sticky_container.innerHTML = ''
        sticky_container.appendChild(cloned_sheet)

    input_ids = [
        "w_line", "w_leader", "w_shape",
        "s_weight", "i_weight", "s_dia", "i_dia", "s_reel", "i_reel",
        "s_dist", "i_dist", "s_target", "i_target", "s_pond", "i_pond",
        "s_start_d", "i_start_d", "s_trig", "i_trig",
        "s_spd_s", "i_spd_s", "s_spd_e", "i_spd_e",
        "s_rod_s", "i_rod_s", "s_rod_e", "i_rod_e", "w_rod_dyn",
        "w_clarity", "w_light", "w_water_color", "w_bottom", "w_wind",
        "w_pause_enable", "s_pause_dur", "i_pause_dur", "s_pause_count", "i_pause_count",
        "s_pause_dist", "i_pause_dist"
    ]
    
    for id in input_ids:
        el = document.getElementById(id)
        if el:
            if el.type == "range":
                el.addEventListener("input", debounce_proxy)
                el.addEventListener("change", update_proxy)
            else:
                el.addEventListener("change", update_proxy)

bind_listeners()
setup_ui_listeners()
document.getElementById("loader").style.display = "none"
update_plot()
    </py-script>
</body>
</html>
